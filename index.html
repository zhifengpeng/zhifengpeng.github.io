<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="最是那一低头的温柔，像一朵水莲花，不胜凉风的娇羞">
<meta name="keywords" content="技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="peter阡陌">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="peter阡陌">
<meta property="og:description" content="最是那一低头的温柔，像一朵水莲花，不胜凉风的娇羞">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="peter阡陌">
<meta name="twitter:description" content="最是那一低头的温柔，像一朵水莲花，不胜凉风的娇羞">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>peter阡陌</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">peter阡陌</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">自由与美</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/JPA Repositories/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/JPA Repositories/" itemprop="url">JPA Repositories</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/JPA Repositories/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/JPA Repositories/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="5-JPA-Repositories"><a href="#5-JPA-Repositories" class="headerlink" title="5. JPA Repositories"></a>5. JPA Repositories</h1><p>test</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/附录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/附录/" itemprop="url">附录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/附录/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/附录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/Spring Data JPA中文参考指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/Spring Data JPA中文参考指南/" itemprop="url">Spring Data JPA中文参考指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/Spring Data JPA中文参考指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/Spring Data JPA中文参考指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring Data JPA中文参考指南</p>
<p>翻译Spring Data JPA 2.0.8官网的<a href="https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/" target="_blank" rel="noopener">参考指南</a>,文章列表如下：</p>
<ul>
<li><a href="https://zhifengpeng.github.io/2018/07/07/translate/springdatajpa/Spring-Data-JPA-2-0-8%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">概述</a></li>
<li><a href="https://zhifengpeng.github.io/2018/07/07/translate/springdatajpa/%E5%89%8D%E8%A8%80/" target="_blank" rel="noopener">前言 1~3</a></li>
<li><a href="https://zhifengpeng.github.io/2018/07/07/translate/springdatajpa/%E4%BD%BF%E7%94%A8Spring%20Data%20Repositories/" target="_blank" rel="noopener">使用Spring Data Repositories 4</a></li>
<li><a href="https://zhifengpeng.github.io/2018/07/07/translate/springdatajpa/JPA%20Repositories/" target="_blank" rel="noopener">JPA Repositories 5</a></li>
<li><a href="https://zhifengpeng.github.io/2018/07/07/translate/springdatajpa/%E9%99%84%E5%BD%95/" target="_blank" rel="noopener">附录</a></li>
</ul>
<p>Spring Data JPA练习项目，<a href="">github地址</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/Spring-Data-JPA-2-0-8概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/Spring-Data-JPA-2-0-8概述/" itemprop="url">Spring Data JPA 2.0.8概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/Spring-Data-JPA-2-0-8概述/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/Spring-Data-JPA-2-0-8概述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring Data JPA是Spring Data大家族中的一员，可以轻松实现基于JPA的存储库。这个模块处理基于JPA的数据访问层的增强支持。<br>它使构建使用数据访问技术的Spring驱动的应用程序变得更加容易。</p>
<p>在相当长的一段时间内，实现应用程序的数据访问层是相当麻烦的。必须编写太多的样板代码来执行简单的查询，以及执行分页和审计。<br>Spring Data JPA旨在减少实际的工作量来显著改善数据访问层的实现。作为开发人员，你编写存储库接口，包括自定义查询方法，然后<br>Spring会自动提供实现。</p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul>
<li>对构建基于Spring和JPA的存储库的复杂支持</li>
<li>支持Querydsl谓词，从而支持类型安全的JPA查询</li>
<li>透明的域类审计</li>
<li>分页支持，动态查询执行，集成自定义数据访问代码的能力</li>
<li>在引导时验证带@Query注释的查询</li>
<li>支持基于XML的实体映射</li>
<li>通过引入@EnableJpaRepositories,启用基于Java配置的存储库配置</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>通过Spring Initializr引导你的应用程序</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/前言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/前言/" itemprop="url">前言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/前言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/前言/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Data JPA提供了支持Java持久化API（JPA）的存储库。它简化了需要访问JPA数据源的应用程序的开发。</p>
<h2 id="1-项目元数据"><a href="#1-项目元数据" class="headerlink" title="1.项目元数据"></a>1.项目元数据</h2><ul>
<li>版本控制-<a href="http://github.com/spring-projects/spring-data-jpa" target="_blank" rel="noopener">http://github.com/spring-projects/spring-data-jpa</a></li>
<li>bug追踪-<a href="https://jira.spring.io/browse/DATAJPA" target="_blank" rel="noopener"> https://jira.spring.io/browse/DATAJPA</a></li>
<li>发行库- <a href="https://repo.spring.io/libs-release" target="_blank" rel="noopener">https://repo.spring.io/libs-release</a></li>
<li>里程碑库 - <a href="https://repo.spring.io/libs-milestone" target="_blank" rel="noopener"> https://repo.spring.io/libs-milestone</a></li>
<li>快照库 - <a href="https://repo.spring.io/libs-snapshot" target="_blank" rel="noopener">https://repo.spring.io/libs-snapshot</a></li>
</ul>
<h2 id="2-更新和注意点"><a href="#2-更新和注意点" class="headerlink" title="2. 更新和注意点"></a>2. 更新和注意点</h2><h3 id="2-1-Spring-Data-JPA-1-11的新功能"><a href="#2-1-Spring-Data-JPA-1-11的新功能" class="headerlink" title="2.1 Spring Data JPA 1.11的新功能"></a>2.1 Spring Data JPA 1.11的新功能</h3><p>Spring Data JPA 1.11 添加了下面特性：</p>
<ul>
<li>改进了和Hibernate 5.2的兼容性</li>
<li>支持按事例查询的任意匹配模式</li>
<li>分页查询优化</li>
<li>支持在存储库查询派生出的已存在部分</li>
</ul>
<h3 id="2-2-Spring-Data-JPA-1-10的新功能"><a href="#2-2-Spring-Data-JPA-1-10的新功能" class="headerlink" title="2.2 Spring Data JPA 1.10的新功能"></a>2.2 Spring Data JPA 1.10的新功能</h3><p>Spring Data JPA 1.10 添加下面的特性：</p>
<ul>
<li>支持在存储库查询方法中的预测</li>
<li>支持按事例查询</li>
<li>已启用以下注释以构建composed注释：@EntityGraph,@Lock,@Modifying,@Query,@QueryHints,and @Procedure.</li>
<li>支持在集合表达式上使用Contains关键字</li>
<li>JSR-310和ThreeTenBp的ZoneId的AttributeConverter实现</li>
<li>升级到Querydsl 4,Hibernate 5,OpenJPA 2.4,和EclipseLink 2.6.1</li>
</ul>
<p>注：2.0.8的版本为什么这里还是1点几的新功能</p>
<h2 id="3-依赖"><a href="#3-依赖" class="headerlink" title="3. 依赖"></a>3. 依赖</h2><p>由于各个Spring Data模块不同的开始时间，它们大多数都有不同的主要版本号和次要版本号。找到兼容版本号最容易的方式是依赖我们跟随的兼容版本定义的Spring Data Release Train BOM。在Maven项目，你可以在POM文件的<dependencymanagement>部分声明如下的依赖：</dependencymanagement></p>
<p>例子1：使用Spring Data Release Train BOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;release-train&#125;&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">      &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<p>当前发行的系列版本是Kay-SR8.系列名称是字母的升序，<a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning" target="_blank" rel="noopener">此处</a>列出了可用的系列。版本名称格式如：${name}-${release},其中的release可以是下列的其中一个：</p>
<ul>
<li>BUILD-SNAPSHOT:当前快照</li>
<li>M1,M2..:里程碑版本</li>
<li>RC1,RC2…：发行候选版本</li>
<li>RELEASE：GA发行</li>
<li>SR1，SR2…: 服务版本</li>
</ul>
<p>在<a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom" target="_blank" rel="noopener">Spring Data examples repository</a>可以找到使用BOMs的例子。有了这个，你可以在<dependencies>区块里声明你想要的Spring Data模块，而不需要版本，如下：</dependencies></p>
<p>例子2：声明一个Spring Data模块的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>注：例子中完整的POM.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;org.springframework.data.examples&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-data-examples-bom&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;Spring Data - Using the BOM for dependency management&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;</span><br><span class="line">		&lt;spring-data.version&gt;Kay-SR2&lt;/spring-data.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-data.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-data-rest-webmvc&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-Spring-Boot的依赖管理"><a href="#3-1-Spring-Boot的依赖管理" class="headerlink" title="3.1 Spring Boot的依赖管理"></a>3.1 Spring Boot的依赖管理</h3><p>Spring Boot 为你选择一个Spring Data模块的当前版本。如果你依然想升级一个更新的版本，配置spring-data-releasetrain.verson参数你想要使用的系列名称和迭代版本。</p>
<h3 id="3-2-Spring框架"><a href="#3-2-Spring框架" class="headerlink" title="3.2 Spring框架"></a>3.2 Spring框架</h3><p>Spring Data模块当前版本要求Spring Framework版本5.0.7以上。这些模块也可以使用次要版本的老板，但是，强烈建议使用该代中的最新版本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/translate/springdatajpa/使用Spring-Data-Repositories/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/translate/springdatajpa/使用Spring-Data-Repositories/" itemprop="url">使用Spring Data Repositories</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T22:01:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Data-JPA-2-0-8-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Data JPA 2.0.8 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/07/translate/springdatajpa/使用Spring-Data-Repositories/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/07/translate/springdatajpa/使用Spring-Data-Repositories/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-使用Spring-Data-Repositories"><a href="#4-使用Spring-Data-Repositories" class="headerlink" title="4. 使用Spring Data Repositories"></a>4. 使用Spring Data Repositories</h1><p>Spring Data repository抽象的目的是极大减少要求实现不同持久化存储的数据访问层的样板代码的数量。</p>
<p>！Spring Data repository文档和你的模块<br>这章解释Spring Data repositories的核心概念和接口。这章信息来自Spring Data Commons模块。它使用Java Persistence API(JPA)模块的配置和代码示例。你应该调整XML命名空间声明和扩展类型为你使用特定模块的等效项。<a href="https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repositories.namespace-reference" target="_blank" rel="noopener">Namespace reference</a>覆盖XML配置，支持repository API的所有Spring Data模块都支持XML配置。<a href="https://docs.spring.io/spring-data/jpa/docs/2.0.8.RELEASE/reference/html/#repository-query-keywords" target="_blank" rel="noopener">Repository query keywords</a>覆盖了repository抽象大体支持的查询方法关键字。想要了解模块特定特征的详细信息，阅读该文档特定模块的章节。</p>
<h2 id="4-1-核心概念"><a href="#4-1-核心概念" class="headerlink" title="4.1 核心概念"></a>4.1 核心概念</h2><p>Spring Data repository abstraction核心接口是Repository。 它将域类和域类的ID类型作为参数进行管理。此接口作为一个标记接口，用来获取使用的类型，并用来帮助你发现集成该类的接口。CrudRepository为正在被管理的类提供复杂的CRUD功能。</p>
<p>注开始：Repository接口，通过泛型，指定实体类和实体类ID类型，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.repository;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Indexed;</span><br><span class="line"></span><br><span class="line">@Indexed</span><br><span class="line">public interface Repository&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现该接口的类有：</p>
<img src="/2018/07/07/translate/springdatajpa/使用Spring-Data-Repositories/repository.png">
<p>注结束。</p>
<p>例子3：CrudRepository接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.repository;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //保存实体</span><br><span class="line">    &lt;S extends T&gt; S save(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    //返回ID标识的实体</span><br><span class="line">    Optional&lt;T&gt; findById(ID var1);</span><br><span class="line"></span><br><span class="line">    //判断是否存在给定ID的实体</span><br><span class="line">    boolean existsById(ID var1);</span><br><span class="line"></span><br><span class="line">    //返回所有实体</span><br><span class="line">    Iterable&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1);</span><br><span class="line"></span><br><span class="line">    //返回实体的个数</span><br><span class="line">    long count();</span><br><span class="line"></span><br><span class="line">    void deleteById(ID var1);</span><br><span class="line"></span><br><span class="line">    //删除实体</span><br><span class="line">    void delete(T var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll(Iterable&lt;? extends T&gt; var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!我们还提供持久化特定技术的抽象类，例如JpaRepository和MongoRepository。除了相当通用的技术无关的持久化接口（如CrudRepository）,这些接口扩展了CrudRepository并且暴露了底层持久化技术的功能。</p>
<p>在CrudRepository之上，PagingAndSortingRepository抽象，添加额外方法来简化实体的分页访问。</p>
<p>例子4. PagingAndSortingRepository接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.repository;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.domain.Page;</span><br><span class="line">import org.springframework.data.domain.Pageable;</span><br><span class="line">import org.springframework.data.domain.Sort;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">    Iterable&lt;T&gt; findAll(Sort var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; findAll(Pageable var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问User的第二页，每页20条记录，你可以像下面这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User,Long&gt; repository = //... 获得bean</span><br><span class="line">Page&lt;User&gt; users = repository.findAll(new Pageable(1,20)); //从0开始</span><br></pre></td></tr></table></figure>
<p>除了查询方法，还可以使用计数和删除查询的查询派生。以下列表展示了派生技术查询的接口定义：</p>
<p>例子 5. 派生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  long countByLastname(String lastname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-2-查询方法"><a href="#4-2-查询方法" class="headerlink" title="4.2. 查询方法"></a>4.2. 查询方法</h2><p>标准的CRUD功能repositories通常对基础数据存储区进行查询。使用Spring Data，申明这些查询，有4个步骤：</p>
<ol>
<li><p>声明一个接口，实现Repository或它的子类，并指定要处理的域类和ID类型，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口声明查询方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line">  List&lt;Person&gt; findByLastname(String lastname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置Spring，为这些接口创建代理实例，不管是用JavaConfig或XML配置<br>a. 使用Java配置，创建一个类似下面的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"></span><br><span class="line">@EnableJpaRepositories</span><br><span class="line">class Config &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>b.使用XML配置，定义一个类似如下的bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">     http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">     http://www.springframework.org/schema/data/jpa</span><br><span class="line">     http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;jpa:repositories base-package=&quot;com.acme.repositories&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个例子使用了JPA命名空间。如果你使用了任何其他存储的repository抽象，你需要修改为你存储模块合适的命名空间声明。换句话说，你需要替换jpa,例如改为mongodb.<br>另外还需注意，JavaConfig配置变量没有指定包，注解类的包被默认使用。如果需要指定包的扫描路径，使用特定数据存储的repository的@Enable${store}Repositories注解的basePackage…属性的一个。</p>
<ol start="4">
<li>注入repository实例并使用它，如下示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SomeClient &#123;</span><br><span class="line"></span><br><span class="line">  private final PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    this.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void doSomething() &#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(&quot;Matthews&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如下的章节详细解释每一步骤：</p>
<ul>
<li>定义Repository接口（4.3）</li>
<li>定义查询方法（4.4）</li>
<li>创建Repository实例（4.5）</li>
<li>自定义实现Spring Data Repository</li>
</ul>
<h2 id="4-3-定义Repository接口"><a href="#4-3-定义Repository接口" class="headerlink" title="4.3 定义Repository接口"></a>4.3 定义Repository接口</h2><p>首先，定义一个特殊域类接口。接口必须继承Repository,并且绑定域类和ID类型。如果你想要暴露域类的CRUD方法，继承CrudRepository代替Repository。</p>
<h3 id="4-3-1-微调Repository定义"><a href="#4-3-1-微调Repository定义" class="headerlink" title="4.3.1 微调Repository定义"></a>4.3.1 微调Repository定义</h3><p>通常，你的repository接口继承Repository,CrudRepository,或者PagingAndSortingRepository。另外，如果你不想继承Spring Data接口，你也可以用@RepositoryDefinition注解你的repository接口。继承CrudRepository暴露一个完整的操作实体方法的集合。如果你更倾向于选择一些方法暴露，从CrudRepository复制一些方法到你的域类。</p>
<p>！这样做可以让你在提供的Spring Data Repositories功能上定义你自己的抽象类。</p>
<p>以下示例演示了如何选择暴露CRUD方法（在这例子里，暴露了findById和save方法）</p>
<p>例子7. 选择暴露CRUD方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; findById(ID id);</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; S save(S entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends MyBaseRepository&lt;User, Long&gt; &#123;</span><br><span class="line">  User findByEmailAddress(EmailAddress emailAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面例子中，你为所有的域类repositories定义了公共基本接口，并且暴露了findById()和save()方法。这些方法被路由到Spring Data提供的你选择的存储的基本repository实现（例如：如果你使用JPA，实现就是SimpleJpaRepository）,因为它们匹配CrudRepository的签名。所以，现在UserRepository可以保存用户，通过id查询用户，并且触发查询通过邮件地址查询用户。</p>
<p>！中间的repository接口被@NoRepositoryBean注解。确保你给所有repository接口添加该注解，以保证Spring Data在运行时不会创建实例。</p>
<h3 id="4-3-2-Repository方法的Null处理"><a href="#4-3-2-Repository方法的Null处理" class="headerlink" title="4.3.2  Repository方法的Null处理"></a>4.3.2  Repository方法的Null处理</h3><p>从Spring Data 2.0开始，repository CRUD方法返回一个使用Java 8的Optional指示潜在空值的单个聚合实例。除此之外，Spring Data支持在查询方法返回如下包装类型：</p>
<ul>
<li>com.google.common.base.Optional</li>
<li>scala.Option</li>
<li>io.vavr.control.Option</li>
<li>javaslang.control.Option(不推荐使用Javaslang)</li>
</ul>
<p>或者，查询方法可以根本不使用包装类型。通过返回null来表明没有查询结果。保证返回集合，集合代替，包装类和流的Repository方法不会返回null，而是返回相应的空表示。查看“Repository查询返回类型”详情。</p>
<p>可空性注解</p>
<p>你可以通过使用Spring框架的可控性注解来表示repository方法的可空性约束。它们在运行时提供了友好的方法和opt-in null检查，如下：</p>
<ul>
<li>@NonNullApi:使用在包级别来声明参数和返回值的默认行为不接受和产生null值。</li>
<li>@NonNull:用在参数和返回值，该值不能为null（参数和返回值不需要使用@NonNullApi）</li>
<li>@Nullable:用在参数和返回值，该值可以为null</li>
</ul>
<p>Spring注解是使用JSR 305注解的元注解（一种休眠但广泛传播的JSR）。JSR 305元注解让IDEA，Eclipse和Kotlin等工具厂商以通用方式提供null值安全的支持，而无须对Spring 注解进行硬编码支持。要对查询方法在运行时检查可空性约束，你需要在package-info.java使用Spring的@NonNullApi在包级别激活非可空性。如下示例：</p>
<p>例子8. 在package-info.java声明非可空性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@org.springframework.lang.NonNullApi</span><br><span class="line">package com.acme;</span><br></pre></td></tr></table></figure>
<p>一旦存在非空默认，repository查询方法在运行时获得可空性约束验证。如果查询执行结果返回了定义约束，会抛出异常。当方法返回null,却声明了非null时就会发生（默认情况下，注解定义在repository所在包上）。如果你想再次选择可以为空的结果，请在各个方法上使用@Nullable。使用本章开头提及的使用结果封装类可以继续如期望那样工作：一个空值转化为代表缺席的值。</p>
<p>如下示例展示了一些刚刚描述的技术：</p>
<p>例子9. 使用不同的可空性约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//repository在一个我们已经定义飞空行为的包里</span><br><span class="line">package com.acme;                                                       </span><br><span class="line"></span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  //当查询执行没有产生结果时抛出EmptyResultDataAccessException异常。当emailAddress为null时抛出IllegalArgumentException异常。</span><br><span class="line">  User getByEmailAddress(EmailAddress emailAddress);                    </span><br><span class="line"></span><br><span class="line">  //当执行没有产生结果返回null，emailAdress也可以接受null</span><br><span class="line">  @Nullable</span><br><span class="line">  User findByEmailAddress(@Nullable EmailAddress emailAdress);          </span><br><span class="line"></span><br><span class="line">  //查询执行没有产生结果返回Optional.empty()(住:没有值的Optional,用isPresent()判断)</span><br><span class="line">  //当emailAddress为null时，抛出IllegalArgumentException异常</span><br><span class="line">  Optional&lt;User&gt; findOptionalByEmailAddress(EmailAddress emailAddress); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于Kotlin的Repositories可空性</p>
<p>（略）</p>
<h3 id="4-3-3-使用多个Spring-Data模块的Repositories"><a href="#4-3-3-使用多个Spring-Data模块的Repositories" class="headerlink" title="4.3.3. 使用多个Spring Data模块的Repositories"></a>4.3.3. 使用多个Spring Data模块的Repositories</h3><p>在你的应用程序中使用一个Spring Data模块使事情简单，因为在定义范围的所有repository接口都绑定到Spring Data模块。有时候，应用要求超过使用一个Spring Data模块。在这种情况下，repository在多个持久化技术之间必须区分定义。当在类路径下检测到多个repository工厂，Spring Data进入严格的repository配置模式。严格配置使用repository和域类详情来决定repository定义的Spring Data模块绑定：</p>
<ol>
<li>如果repository定义继承自特殊模块的repository,那么它是特定Spring Data模块的有效候选者。</li>
<li>如果域类被特殊模块类型注解注解，那么它是特定Spring Data模块的有效候选者。Spring Data即接收第三方注解（例如JPA的@Entity），也会提供自己的注解（例如Spring Data MongoDB和Spring Data Elasticsearch的@Document）。</li>
</ol>
<p>如下示例展示使用特定模块接口的repository(再这个例子中是JPA)：</p>
<p>例子11：使用特定模块接口的Repository定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyRepository extends JpaRepository&lt;User, Long&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends JpaRepository&lt;T, ID&gt; &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends MyBaseRepository&lt;User, Long&gt; &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyRepository和UserRepository在他们的类关系中继承了JpaRepository。他们是Spring Data JPA模块的有效候选者。</p>
<p>如下示例展示使用普通接口的repository:</p>
<p>例子12：使用通用接口的repository定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface AmbiguousRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AmbiguousUserRepository extends MyBaseRepository&lt;User, Long&gt; &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AmbiguousRepository和AmbiguousUserRepository在类关系中仅继承Repository和CrudRepository。当使用唯一的Spring Data模块这样是可行的，然而在多个模块无法区分这些repositories应该绑定到哪个特定的Spring Data。</p>
<p>如下示例展示使用注解域类的repository:</p>
<p>例子13：使用注解域类的Repository定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document</span><br><span class="line">class User &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PersonRepository引用Person，它使用JPA的@Entity注解，所以这个repository明显属于Spring Data JPA。UserRepository引用User,它被Spring Data MongoDB的@Document注解。</p>
<p>下列不正确的示例展示一个repository使用混合注解的域类：</p>
<p>例子14.使用混合注解域类的Repository定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Document</span><br><span class="line">class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子展示了一个域类即使用JPA注解，又使用Spring Data MongoDB注解。它定义了两个repositories,JpaPersonRepository和MongoDBPersonRepository。一个用于JPA，一个用于MongoDB。Spring Data不能够区分repositories部分，导致没有定义。</p>
<p> 严格repository配置使用repository类型详情和可区分的域类注解来鉴定Spring Data模块的repository候选人。在同一个域类使用多个持久化特定技术的注解是可能的，也允许跨多个持久化技术重用域类。然而，Spring Data不再能够决定绑到repository的唯一模块。</p>
<p> 区分repository的最后一种方法是通过限定repository基础包的范围。基础包定义了扫描repository接口定义的起点，意味着repository定义放置在相应的包中。默认情况下，注解驱动的配置使用配置类的包。基于XML配置中基础包是必须的。</p>
<p> 如下示例展示基础包的注解驱动的配置：</p>
<p> 例子15：基础包的注解驱动配置<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span><br><span class="line">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span><br><span class="line">interface Configuration &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-4-定义查询方法"><a href="#4-4-定义查询方法" class="headerlink" title="4.4.定义查询方法"></a>4.4.定义查询方法</h2><p>repository代理有两个方法从方法名派生出特殊存储的查询</p>
<ul>
<li>直接从方法名派生查询</li>
<li>使用手工定义查询</li>
</ul>
<p>可用选项取决于实际存储库。然而，必须有一个策略来决定被创建的实际查询。下一章节讨论可用选项。</p>
<h3 id="4-4-1-查询查找策略"><a href="#4-4-1-查询查找策略" class="headerlink" title="4.4.1 查询查找策略"></a>4.4.1 查询查找策略</h3><p>下列策略对于repository基础架构解决查询是可选择的。使用XML配置，你可以通过查询查找策略在命名空间配置策略。使用Java配置，你可以使用Enable${store}Repositories注解的查询查找策略属性。对于特定数据库有些策略可能不被支持。</p>
<ul>
<li>CREATE尝试从查询方法名称构建特殊存储库查询。一般方法是删除一组已知的方法名的前缀，并解析方法剩余部分。你可以在“Query Creation”读取更多关于查询构造的信息。</li>
<li>USE_DECLARED_QUERY 尝试查找声明的查询，如果找不到，就抛出异常。查询可以通过某处的注解来定义，或其他方式声明。查询特定存储文档来查找该存储的有效的选项。如果repository基础架构在引导时如果不能找到方法的声明查询，就失败。</li>
<li>CREATE_IF_NOT_FOUND(默认)结合了CREATE和USE_DECLARED_QUERY.它首先查找声明查询，然后如果声明查询没有找到，它创建一个基于名称查询的自定义方法。这是默认查找策略，因此，如果你没有明确配置任何策略，它就被使用。它允许通过方法名快速查询定义，还可以通过引入需要的声明查询来定义这些查询。</li>
</ul>
<h3 id="4-4-2-查询创建"><a href="#4-4-2-查询创建" class="headerlink" title="4.4.2. 查询创建"></a>4.4.2. 查询创建</h3><p>构建Spring Data repository基础结构的查询构建机制对于构建repository实体的约束查询是有用的。该机制从方法剥夺前缀（find…By,read…By,query…By,count…By,get…By）然后开始解析剩余部分。介绍的短语可以包含更多表达式，例如Distinct在被创建的查询中设置一个区别标志。但是，第一个By作为分隔符来标示查询条件的开始。在一个非常基础的级别，你可以在实体属性上定义条件，并用And和Or连接它们。下列例子展示如何创建一系列查询：</p>
<p>例子16.从方法名称查询构建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);</span><br><span class="line"></span><br><span class="line">  // Enables the distinct flag for the query</span><br><span class="line"> //可以在查询使用distinct标志</span><br><span class="line">  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);</span><br><span class="line">  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);</span><br><span class="line"></span><br><span class="line">  // Enabling ignoring case for an individual property</span><br><span class="line">  //可以忽略单个属性的大小写</span><br><span class="line">  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);</span><br><span class="line">  // Enabling ignoring case for all suitable properties</span><br><span class="line">  //可以忽略所有合适属性的大小写</span><br><span class="line">  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);</span><br><span class="line"></span><br><span class="line">  // Enabling static ORDER BY for a query</span><br><span class="line">  // 可以在查询使用静态ORDER</span><br><span class="line">  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);</span><br><span class="line">  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>派生方法实际结果依赖你创建查询的持久化存储。然而，有一些共性要注意：</p>
<ul>
<li>表达式通常是属性和可以被连接的操作相结合。你可以使用AND和OR连接属性表达式。你也可以获得属性表达式操作的支持，例如Between,LessThan,GreaterThan和Like。不同的数据库支持的操作不一样，所以要参考相关文档适当的部分。</li>
<li>方法解析器支持为各个属性设置IgnoreCase标志（例如，findByLastnameIgnoreCase(…)）或者为支持忽略大小写类型的所有属性（通常是String实例，例如，findByLastnameAndFirstnameAllIgnoreCase(…)）。是否支持忽略大小写对于不同存储会不相同，所以为特殊存储查询方法参考参考文档的相关章节。</li>
<li>你可以使用静态排序，通过添加OrderBy短语到引用一个属性的查询方法和提供一个排序指示（Ase或者Desc）.创建支持动态排序的查询方法，请看“Special parameter handling”。</li>
</ul>
<h3 id="4-4-3-参数表达式"><a href="#4-4-3-参数表达式" class="headerlink" title="4.4.3. 参数表达式"></a>4.4.3. 参数表达式</h3><p>参数表达式可以只引用管理实体的直接属性，如之前例子展示那样。在查询创建时，你已经确定派生方法是管理域类的一个属性。但是，你也可以通过遍历嵌套属性来定义约束。考虑如下方法签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</span><br></pre></td></tr></table></figure></p>
<p>假设一个Person有一个带有ZipCode的Address。在这个例子中，方法创建属性遍历x.address.zipCode。解析算法首先把这个部分（AddressZipCode）当做属性，然后检查域类是否有这样一个属性（未大写）。如果算法成功，则使用该属性，如果不成功，算法在从右边驼峰大写部分拆分为一个头部和一个尾部，然后尝试找到相应的属性-在我们的例子中，分为AddresZip和Code。如果算法找到以那开头的属性，继续拿到尾部，从那里构建树，用刚才描述的方法拆分尾部。如果第一部分没有匹配，算法向左移动拆分点（Address,ZipCode）,然后继续。</p>
<p>尽管这在大多数情况下可行的，但是该算法还是有可能选择到了错误的属性。假设Person类也有一个addressZip属性。算法会在第一次拆分时匹配成功，选择到错的属性，然后失败（因为addressZip属性可能没有code属性）。</p>
<p>为解决这个模糊情况，你可以使用_插入方法名以手工定义遍历点。所以我们的方法名会如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);</span><br></pre></td></tr></table></figure></p>
<p>因为我们把下划线字符当作保留字符，我们强烈建议使用标准的Java命名规范（就是使用驼峰命名代替下划线在属性名中）。</p>
<h3 id="4-4-4-特殊参数处理"><a href="#4-4-4-特殊参数处理" class="headerlink" title="4.4.4. 特殊参数处理"></a>4.4.4. 特殊参数处理</h3><p>在查询中处理参数，在之前的例子中已经看到定义方法参数。除此之外，基础架构推荐确定的特殊类型，例如Pageable和Sort,用来在你的查询中动态分页和排序。如下示例展示了这些特征：</p>
<p>例子17： 在查询方法使用Pageable,Slice和Sort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findByLastname(String lastname, Sort sort);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</span><br></pre></td></tr></table></figure></p>
<p>第一个方法让你给查询方法传递一个 org.springframework.data.domain.Pageable实例来给静态定义查询添加动态分页。Page有元素的总个数和可用的分页数。基础架构触发一个计数查询来计算实例的总数。这样可能是耗性能的（取决于使用的存储），你可以使用Slice代替。Slice仅知道是否有下一个Slice可用，这样在一个大的结果集中可能会高效点。</p>
<p>分页选项也可以通过Pageable实例处理。如果你只需要排序，给方法传递一个org.springframework.data.domain.Sort实例。正如你可以看到的，返回一个List也是可能的。在这种情况下，构建一个分页实例额外的元数据不会被创建（意味着必要的计数查询不会被发生）。相反，它限制查询查找实体给定的范围。</p>
<p>！找出一个实体查询你可以获得多少个分页，你需要触发额外的计数查询。默认情况下，这个查询从你实际触发查询中派生出来。</p>
<h3 id="4-4-5-限制查询结果"><a href="#4-4-5-限制查询结果" class="headerlink" title="4.4.5. 限制查询结果"></a>4.4.5. 限制查询结果</h3><p>查找方法的结果可以通过使用first和top关键字来限制，这些关键字可以交换使用。一个可选的数值可以被添加到top和first来限定返回的最大结果。如果省略了数字，默认值是1。如下示例展示如何限制查询大小：</p>
<p>例子18： 限制使用Top和First查询的结果大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User findFirstByOrderByLastnameAsc();</span><br><span class="line"></span><br><span class="line">User findTopByOrderByAgeDesc();</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</span><br></pre></td></tr></table></figure></p>
<p>限制表达式也支持Distinct关键字。此外，对于查询限制结果集为一个实例，支持用Optional关键字包装结果。</p>
<p>如果pagination和slicing应用于限制查询分页（可用页数的计算），在限制结果中应用。</p>
<p>！通过使用Sort参数，限制结果结合动态查询，让你表达’K’最小和‘K’最大元素的查询方法。</p>
<h3 id="4-4-6-流式查询结果"><a href="#4-4-6-流式查询结果" class="headerlink" title="4.4.6. 流式查询结果"></a>4.4.6. 流式查询结果</h3><p>查询方法的结果集可以通过使用Java 8的Stream<t>作为返回类型被递增处理。代替将查询结果封装在Stream，数据特殊存储方法用于执行流式查询，如下示例：</t></p>
<p>例子19. 使用Java 8 Stream<t>的流式查询结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select u from User u&quot;)</span><br><span class="line">Stream&lt;User&gt; findAllByCustomQueryAndStream();</span><br><span class="line"></span><br><span class="line">Stream&lt;User&gt; readAllByFirstnameNotNull();</span><br><span class="line"></span><br><span class="line">@Query(&quot;select u from User u&quot;)</span><br><span class="line">Stream&lt;User&gt; streamAllPaged(Pageable pageable);</span><br></pre></td></tr></table></figure></t></p>
<p>!Stream可能潜在包装底层数据特殊存储资源，所以必须在使用后关闭。你可以使用close()方法手动关闭Stream，也可以使用Java 7 的try-with-resources块，如下示例展示：</p>
<p>例子20. 在try-with-resources块中使用Stream<t>结果集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>!不是所有的Spring Data模块在现阶段支持Stream<t>作为返回类型</t></p>
<h3 id="4-4-7-异步查询结果"><a href="#4-4-7-异步查询结果" class="headerlink" title="4.4.7. 异步查询结果"></a>4.4.7. 异步查询结果</h3><p>通过使用Spring的异步方法执行能力，repositories查询可以异步执行。这意味着方法调用时立即返回，而实际查询执行发生在被提交到Spring TaskExecutor的任务。异步查询执行和响应查询执行不同，并不能混合。参考特殊存储文档获得响应支持细节。如下示例展示一些异步查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用java.util.concurrent.Future作为返回类型</span><br><span class="line">@Async</span><br><span class="line">Future&lt;User&gt; findByFirstname(String firstname);               </span><br><span class="line"></span><br><span class="line">//使用Java 8的java.util.concurrent.CompletableFuture作为返回类型</span><br><span class="line">@Async</span><br><span class="line">CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); </span><br><span class="line"></span><br><span class="line">//使用org.springframework.util.concurrent.ListenableFuture作为返回类型</span><br><span class="line">@Async</span><br><span class="line">ListenableFuture&lt;User&gt; findOneByLastname(String lastname);</span><br></pre></td></tr></table></figure>
<h2 id="4-5-创建Repository实例"><a href="#4-5-创建Repository实例" class="headerlink" title="4.5. 创建Repository实例"></a>4.5. 创建Repository实例</h2><p> 在这章，为定义的repository接口创建实例和bean定义。一个方法是通过使用支持repository机制的Spring Data模块一起附带的Spring命名空间，尽管我们通常建议使用Java配置。</p>
<h3 id="4-5-1-XML配置"><a href="#4-5-1-XML配置" class="headerlink" title="4.5.1 XML配置"></a>4.5.1 XML配置</h3><p> 每个Spring Data模块包含一个让你定义Spring可以为你扫描的基本包的repositories元素，如下示例：<br> 例子21. 通过XML使用Spring Data repositories</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans:beans xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns=&quot;http://www.springframework.org/schema/data/jpa&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://www.springframework.org/schema/data/jpa</span><br><span class="line">    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;repositories base-package=&quot;com.acme.repositories&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans:beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，Spring扫描com.acme.repositories及子包下继承Repository或子接口的接口。对于每个找到的接口，基础结构会注册持久化特殊技术FactoryBean来创建处理查询方法调用的相应代理。每一个bean被用接口名注册，例如一个UserRepository接口会被注册名为userRepository的bean。base-package属性支持通配符，所以你可以定义扫描包的模式（正则表达式）。</p>
<p>使用过滤器</p>
<p>默认情况下，基础结构会选择位于配置基础包下继承持久化特殊技术Repository子接口的每一个接口，并为它创建bean实例。然而，你可能想要对某个接口为它们创建实例进行更细粒度的控制。这样做，在<repositories>元素内使用<include-filter>和<exclude-filter>元素。语义完成等同于spring上下文中的命名空间。查看详情，为这些元素请看Spring 参考文档。</exclude-filter></include-filter></repositories></p>
<p>例子，从基础结构排除确认接口作为repository的bean,你可以使用如下配置：</p>
<p>例子22. 使用exclude-filter元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-package=&quot;com.acme.repositories&quot;&gt;</span><br><span class="line">  &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;.*SomeRepository&quot; /&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></p>
<p>前面例子排除所有以SomeRepository结尾的接口被创建实例。</p>
<h3 id="4-5-2-Java配置"><a href="#4-5-2-Java配置" class="headerlink" title="4.5.2. Java配置"></a>4.5.2. Java配置</h3><p>repository基础结构也可以通过在Java配置类上使用特定存储的@Enable${store}Repositories注解来触发。对于基于Java的Spring容器配置的介绍，请看Spring参考文档中的Java配置。</p>
<p>启用Spring Data repositories的样例配置如下：</p>
<p>例子23. 基于注解repository配置的样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJpaRepositories(&quot;com.acme.repositories&quot;)</span><br><span class="line">class ApplicationConfiguration &#123;</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  EntityManagerFactory entityManagerFactory() &#123;</span><br><span class="line">    // …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>!前面的例子使用特殊的JPA注解，你可以根据你实际使用的存储模块改变。同样应用EntityManagerFactory bean的定义。查看特殊存储配置的章节。</p>
<h3 id="4-5-3-独立使用"><a href="#4-5-3-独立使用" class="headerlink" title="4.5.3. 独立使用"></a>4.5.3. 独立使用</h3><p>你也可以在Spring容器外使用repository基础结构，例如在CDI环境。你依然需要一些Spring依赖在类路径下，但是，一般情况下，你也可以通过编程的方式构建repositories.提供的repository支持的Spring Data 模块附带一个持久化特定技术的你可以像下面使用的RepositoryFactory:</p>
<p>例子24. 单独使用repository工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RepositoryFactorySupport factory = … // Instantiate factory here</span><br><span class="line">UserRepository repository = factory.getRepository(UserRepository.class);</span><br></pre></td></tr></table></figure></p>
<h2 id="4-6-Spring-Data-Repositories的自定义实现"><a href="#4-6-Spring-Data-Repositories的自定义实现" class="headerlink" title="4.6. Spring  Data Repositories的自定义实现"></a>4.6. Spring  Data Repositories的自定义实现</h2><p>这章介绍repository自定义，以及碎片如何形成复合repository。</p>
<p>当一个查询方法要求不同的行为，或者不嗯能够从查询派生实现时，需要提供自定义实现。Spring Data让你提供自定义代码，并且整合通用的CRUD抽象和查询方法功能。</p>
<h3 id="4-6-1-定义单个repositories"><a href="#4-6-1-定义单个repositories" class="headerlink" title="4.6.1. 定义单个repositories"></a>4.6.1. 定义单个repositories</h3><p>使用自定义功能丰富repository,你首先要定义一个片段接口，然后实现自定义功能，如下列所示：</p>
<p>例子25. 自定义repository功能的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface CustomizedUserRepository &#123;</span><br><span class="line">  void someCustomMethod(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以让你的repository接口添加继承片段接口，如下示例：</p>
<p>例子26. 定义repository功能实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomizedUserRepositoryImpl implements CustomizedUserRepository &#123;</span><br><span class="line"></span><br><span class="line">  public void someCustomMethod(User user) &#123;</span><br><span class="line">    // Your custom implementation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>! 与片段接口对应的类名最重要的部分是Impl后缀</p>
<p>实现本身不依赖Spring Data,可以被当作普通的Spring bean。因此，你可以使用依赖注入行为注入引入到其他beans（例如一个JdbcTemplate）,在切面作为一部分，等等。</p>
<p>你可以让你的repository接口继承片段接口，如下示例：</p>
<p>例子27. 改变你的repository接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedUserRepository &#123;</span><br><span class="line"></span><br><span class="line">  // Declare query methods here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用repository接口扩展片段接口组合CRUD，自定义功能，并使它对客户端是可用的。</p>
<p>Spring Data repositories通过使用形成repository组合的片段来实现。Fragments(注：片段、碎片不知怎么翻译)是基本的repository，功能方面（例如QueryDsl）,自定义接口及其实现。每次你向你的repository接口添加一个接口时，通过添加一个fragment来增加组合。每个Spring Data模块都提供基本的repository和repository方面实现。</p>
<p>如下示例展示定义接口和它们的实现：</p>
<p>例子28. Fragments和它们的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface HumanRepository &#123;</span><br><span class="line">  void someHumanMethod(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HumanRepositoryImpl implements HumanRepository &#123;</span><br><span class="line"></span><br><span class="line">  public void someHumanMethod(User user) &#123;</span><br><span class="line">    // Your custom implementation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ContactRepository &#123;</span><br><span class="line"></span><br><span class="line">  void someContactMethod(User user);</span><br><span class="line"></span><br><span class="line">  User anotherContactMethod(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContactRepositoryImpl implements ContactRepository &#123;</span><br><span class="line"></span><br><span class="line">  public void someContactMethod(User user) &#123;</span><br><span class="line">    // Your custom implementation</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public User anotherContactMethod(User user) &#123;</span><br><span class="line">    // Your custom implementation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下示例展示了继承了CrudRepository的自定义repository接口：</p>
<p>例子29. 改变你的repository接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface UserRepository extends CrudRepository&lt;User, Long&gt;, HumanRepository, ContactRepository &#123;</span><br><span class="line"></span><br><span class="line">  // Declare query methods here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Repositories可以被多个自定义实现组成，这些实现按声明的顺序导入。自定义实现有更高的优先级比起基本实现和repository方面。如果两个fragments有同样的方法签名，这个排序让你重写基本repository和切面方法和解决歧意。Repository fragments不被限制在一个repository接口使用。多个repositories也可以使用fragment接口，让你通过不同的repository重新使用自定义。</p>
<p>如下示例展示repository fragment和它的实现：</p>
<p>例子30. Fragments覆盖save(…)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface CustomizedSave&lt;T&gt; &#123;</span><br><span class="line">  &lt;S extends T&gt; S save(S entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomizedSaveImpl&lt;T&gt; implements CustomizedSave&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  public &lt;S extends T&gt; S save(S entity) &#123;</span><br><span class="line">    // Your custom implementation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下示例展示使用之前repository fragment的repository:</p>
<p>例子31：自定义repository接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedSave&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PersonRepository extends CrudRepository&lt;Person, Long&gt;, CustomizedSave&lt;Person&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置</p>
<p>如果你使用命名空间配置，repository基础结构尝试自动检测自定义实现fragments，通过扫描它找到repository包下的类。这些类需要遵循将命名空间元素的repository-impl-postfiex属性附加到fragment接口名的命名规范。这个后缀默认为Impl。如下示例展示了使用默认后缀的repository和自定义后缀值的repository.</p>
<p>例子32. 配置例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-package=&quot;com.acme.repository&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;repositories base-package=&quot;com.acme.repository&quot; repository-impl-postfix=&quot;MyPostfix&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>前面示例的第一个配置尝试查找一个叫com.acme.repository.CustomizedUserRepositoryImpl 类来作为自定义repository实现。第二个例子尝试查找com.acme.repository.CustomizedUserRepositoryMyPostfix。</p>
<p>解决歧义</p>
<p>如果多个匹配类名的实现在不同的包下找到，Spring Data使用bean名称去标识哪一个去使用。</p>
<p>给定前面展示的CustomizedUserRepository的如下两个自定义实现，第一个实现被使用，它的bean名称是customizedUserRepositoryImpl,匹配fragment接口（CustomizedUserRepository）添加的Impl后缀。</p>
<p>例子33.解决歧义实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.acme.impl.one;</span><br><span class="line"></span><br><span class="line">class CustomizedUserRepositoryImpl implements CustomizedUserRepository &#123;</span><br><span class="line"></span><br><span class="line">  // Your custom implementation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.acme.impl.two;</span><br><span class="line"></span><br><span class="line">@Component(&quot;specialCustomImpl&quot;)</span><br><span class="line">class CustomizedUserRepositoryImpl implements CustomizedUserRepository &#123;</span><br><span class="line"></span><br><span class="line">  // Your custom implementation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你用@Component(“specialCustom”)注解UserRepository,bean的名字加上Impl,然后就匹配定义在com.acme.impl.two的repository实现，从而代替第一个。</p>
<p>手动接线</p>
<p>如果你的自定义实现仅使用基于注解的配置和自动装配，前面展示的方法效果很好，因为它被当作任何一个其他Spring bean处理。如果你实现的fragment bean 需要特殊接线，你可以声明bean，并根据前面章节描述的约束命名它。然后基础结构通过名字手工定义bean的定义，而不是创建一个。如下示例展示如何手动连接自定义是实现：</p>
<p> 例子34. 手动连接自定义实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-package=&quot;com.acme.repository&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans:bean id=&quot;userRepositoryImpl&quot; class=&quot;…&quot;&gt;</span><br><span class="line">  &lt;!-- further configuration --&gt;</span><br><span class="line">&lt;/beans:bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-6-2-自定义基础repository"><a href="#4-6-2-自定义基础repository" class="headerlink" title="4.6.2. 自定义基础repository"></a>4.6.2. 自定义基础repository</h3><p>前面章节介绍的方法要求当你想要自定义基本repository行为时自定义每个repository接口，以至于所有的repositories都受到影响。为了避免对所有repositories改变行为，你可以创建一个继承持久化特定技术的repository基本类的实现。然后这个类扮演一个repository代理的自定义的基本类，如下所示：</p>
<p>例子35. 自定义repository基础类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyRepositoryImpl&lt;T, ID extends Serializable&gt;</span><br><span class="line">  extends SimpleJpaRepository&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private final EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  MyRepositoryImpl(JpaEntityInformation entityInformation,</span><br><span class="line">                          EntityManager entityManager) &#123;</span><br><span class="line">    super(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">    // Keep the EntityManager around to used from the newly introduced methods.</span><br><span class="line">    this.entityManager = entityManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Transactional</span><br><span class="line">  public &lt;S extends T&gt; S save(S entity) &#123;</span><br><span class="line">    // implementation goes here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> ！类需要一个父类的构造器，特定存储repository工厂实现使用。如果repository基础类有多个构造器，覆盖采用EntityInformation和特定存储基础结构类的一个（例如一个EntityManager或者一个模板类）。</p>
<p> 最后一步是使Spring Data基础结构知道自定义的repository基础类。在Java配置中，你可以使用@Enable${store}Repositories注解的repositoryBaseClass属性来做，如下示例：</p>
<p> 例子36. 使用Java配置，配置自定义repository基础类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)</span><br><span class="line">class ApplicationConfiguration &#123; … &#125;</span><br></pre></td></tr></table></figure></p>
<p>在XML命名空间一个相应的属性是可用的，如下示例：</p>
<p>例子37. 使用XML配置一个自定义的repository基础类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-package=&quot;com.acme.repository&quot;</span><br><span class="line">     base-class=&quot;….MyRepositoryImpl&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-7-从聚合根发布事件"><a href="#4-7-从聚合根发布事件" class="headerlink" title="4.7. 从聚合根发布事件"></a>4.7. 从聚合根发布事件</h2><p>由repositories管理的实体是聚合根。在一个域驱动设计引用中，这些聚合根通常发布域事件。Spring Data 提供一个叫@DomainEvents的注解，你可以在你的聚合根的方法上使用它，尽可能使发布简单，如下示例：</p>
<p>例子38. 从聚合根暴露域事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AnAggregateRoot &#123;</span><br><span class="line"></span><br><span class="line">    //使用@DomainEvents方法可以返回单个事件实例或事件集合，它必须不带有任何参数</span><br><span class="line">    @DomainEvents </span><br><span class="line">    Collection&lt;Object&gt; domainEvents() &#123;</span><br><span class="line">        // … return events you want to get published here</span><br><span class="line">        // 返回要在此处发布的事件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 所有事件都被发布后，我们有个被@AfterDomainEventPublication注解的方法。它可能被用来清理发布事件的列表（或其实用途）</span><br><span class="line">    @AfterDomainEventPublication </span><br><span class="line">    void callbackMethod() &#123;</span><br><span class="line">       // … potentially clean up domain events list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用一个Spring Data repository的save(…)方法时，这些方法都会被调用。</p>
<h2 id="4-8-Spring-Data扩展"><a href="#4-8-Spring-Data扩展" class="headerlink" title="4.8. Spring Data扩展"></a>4.8. Spring Data扩展</h2><p>本章描述了一组Spring Data的扩展，可以使Spring Data在不同的上下文可以使用。目前，大多数集合都指向Spring MVC。</p>
<h3 id="4-8-1-Querydsl扩展"><a href="#4-8-1-Querydsl扩展" class="headerlink" title="4.8.1 Querydsl扩展"></a>4.8.1 Querydsl扩展</h3><p>Querydsl是一个框架，可以通过流式API构建静态类型SQL类查询。</p>
<p>几个Spring Data模块支持通过QuerydslPredicateExecutor整合Querydsl,如下示例：</p>
<p>例子39. QuerydslPredicateExecutor接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.querydsl;</span><br><span class="line"></span><br><span class="line">import com.querydsl.core.types.OrderSpecifier;</span><br><span class="line">import com.querydsl.core.types.Predicate;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import org.springframework.data.domain.Page;</span><br><span class="line">import org.springframework.data.domain.Pageable;</span><br><span class="line">import org.springframework.data.domain.Sort;</span><br><span class="line"></span><br><span class="line">public interface QuerydslPredicateExecutor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //查找和返回匹配Predicate的单个实例</span><br><span class="line">    Optional&lt;T&gt; findOne(Predicate var1);</span><br><span class="line"></span><br><span class="line">    //查找和返回匹配Predicate的所有实例</span><br><span class="line">    Iterable&lt;T&gt; findAll(Predicate var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAll(Predicate var1, Sort var2);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAll(Predicate var1, OrderSpecifier... var2);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAll(OrderSpecifier... var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; findAll(Predicate var1, Pageable var2);</span><br><span class="line"></span><br><span class="line">    //返回匹配Predicate的实体个数</span><br><span class="line">    long count(Predicate var1);</span><br><span class="line"></span><br><span class="line">    // 返回是否存在匹配Predicate的实体</span><br><span class="line">    boolean exists(Predicate var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确保支持Querydsl，继承QuerydslPredicateExecutor在你的repository接口，如下示例：</p>
<p>例子40. Quereydsl整合repositories<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的例子让你使用Querydsl的Predicate实例写类型安全的查询，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = user.firstname.equalsIgnoreCase(&quot;dave&quot;)</span><br><span class="line">	.and(user.lastname.startsWithIgnoreCase(&quot;mathews&quot;));</span><br><span class="line"></span><br><span class="line">userRepository.findAll(predicate);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-8-2-Web支持"><a href="#4-8-2-Web支持" class="headerlink" title="4.8.2 Web支持"></a>4.8.2 Web支持</h3><p>!本节包含Spring Data Web支持的文档，因为它在Spring Data Commons当前（或更高）版本实现。新引入的支持改变了很多东西，所以我们在[web.legacy]保留之前行为的文档。</p>
<p>支持repository编程模式的Spring Data模块附带有不同的web支持。Web相关组件要求Spring MVC的jar包在类路径下。其中一些甚至提供Spring HATEOAS的整合（注：Spring HATEOAS 是一个用于支持实现超文本驱动的 REST Web 服务的开发库。是 HATEOAS 的实现。）。通常在Java配置类使用@EnableSpringDataWebSupport注解来开始整合支持，如下示例：</p>
<p>例子41. 开启Spring Data Web支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">@EnableSpringDataWebSupport</span><br><span class="line">class WebConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@EnableSpringDataWebSupport注解注册了一些组件，稍后会讨论。它会检测类路径下的Spring HATEOAS，如果存在，则注册组合组件。</p>
<p>或者，如果你使用XML配置，注册SpringDataWebConfiguration和HateoasAwareSpringDataWebConfiguration当做Spring的bean，如下示例：</p>
<p>例子42. 在XML开启对Spring Data Web的支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.data.web.config.SpringDataWebConfiguration&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>基础web支持</strong></p>
<p>之前展示的配置注册了一些基本组件：</p>
<ul>
<li>DomainClassConverter让Spring MVC从请求参数或路径变量解析为repository管理的域类实例</li>
<li>HandlerMethodArgumentResolver实现让Spring MVC从请求参数解析Pageable和Sort实例</li>
</ul>
<p>DomainClassConverter</p>
<p>DomainClassConverter让你在Spring MVC控制类的方法签名中直接使用域类，以至于你不需要通过repository手动查找实例，如下示例：</p>
<p>例子43. Spring MVC控制层在方法签名使用域类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/users&quot;)</span><br><span class="line">class UserController &#123;</span><br><span class="line"></span><br><span class="line">  @RequestMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">  String showUserForm(@PathVariable(&quot;id&quot;) User user, Model model) &#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    return &quot;userForm&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的，方法直接接受一个User实例，并且不需要进一步的查找。首先，通过让Spring MVC转变参数变量为域类的id类型解析实例，最后，通过调用为域类注册的repository实例的findById(…)方法访问实例。</p>
<p>！当前，repository必须实现CrudRepository才有资格被发现进行转换。</p>
<p>Pageable和Sort的HandlerMethodArgumentResolvers</p>
<p>上一节展示的配置片段注册了PageableHandlerMethodArgumentResolver和SortHandlerMethodArgumentResolver的实例。注册使Pageable和Sort可以作为控制层方法的参数，如下示例：</p>
<p>例子44. 使用Pageable作为控制层方法参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/users&quot;)</span><br><span class="line">class UserController &#123;</span><br><span class="line"></span><br><span class="line">  private final UserRepository repository;</span><br><span class="line"></span><br><span class="line">  UserController(UserRepository repository) &#123;</span><br><span class="line">    this.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RequestMapping</span><br><span class="line">  String showUsers(Model model, Pageable pageable) &#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;users&quot;, repository.findAll(pageable));</span><br><span class="line">    return &quot;users&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的方法签名导致Spring MVC尝试通过使用下列默认配置中从请求参数派生Pageable实例：</p>
<p>Table 1. 为Pageable实例评估请求参数</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>page</td>
<td>你想要请求的页面，下标0开始，默认0</td>
</tr>
<tr>
<td>size</td>
<td>每个分页的大小，默认20</td>
</tr>
<tr>
<td>sort</td>
<td>应按格式property,property(,ASC或者DESC)排序的属性。默认排序方向是升序。如果你需要切换排序方向，使用多个sort参数，例如：?sort=firstname&amp;sort=lastname,asc</td>
</tr>
</tbody>
</table>
<p>定制行为，注册一个bean,各自实现PageableHandlerMethodArgumentResolverCustomizer的接口和ortHandlerMethodArgumentResolverCustomizer的接口。调用customize()方法，让你改变设置，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Bean SortHandlerMethodArgumentResolverCustomizer sortCustomizer() &#123;</span><br><span class="line">    return s -&gt; s.setPropertyDelimiter(&quot;&lt;--&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置一个存在的MethodArgumentResolver的参数不满足你的目标，你可以继承SpringDataWebConfiguration或者启动HATEOAS的等效项，重写pageableResolver()或者sortResolver()方法，并导入自定义配置文件，而不是使用@Enable注解。</p>
<p>如果你需要从请求中处理多个Pageable或Sort示例（例如多个table），你可以使用spring的@Qualifier注解区分不同实例。请求参数需要加上${qualifier}_前缀。如下示例展示生成的方法签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String showUsers(Model model,</span><br><span class="line">      @Qualifier(&quot;thing1&quot;) Pageable first,</span><br><span class="line">      @Qualifier(&quot;thing2&quot;) Pageable second) &#123; … &#125;</span><br></pre></td></tr></table></figure></p>
<p>你需要填充thing1_page和thing2_page等。</p>
<p>默认Pageable传递到方法等同于Pageable(0,20),但是你可以通过在Pageable参数使用@PageableDefault注解定制化。</p>
<p><strong>对Pageables的超媒体支持</strong></p>
<p>Spring HATEOAS附带一个表示模型类（PageResource）,允许你用必要的Page元数据丰富Page实例的内容，和使客户端轻松导航page。从Page到PageResource的转变需要实现Spring HATEOAS的ResourceAssembler 接口，该接口叫PagedResourcesAssembler。如下示例展示如何使用PagedResourcesAssembler 作为控制类方法的参数：</p>
<p>例子45. 使用PagedResourcesAssembler 作为控制类方法参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">class PersonController &#123;</span><br><span class="line"></span><br><span class="line">  @Autowired PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  @RequestMapping(value = &quot;/persons&quot;, method = RequestMethod.GET)</span><br><span class="line">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</span><br><span class="line">    PagedResourcesAssembler assembler) &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;Person&gt; persons = repository.findAll(pageable);</span><br><span class="line">    return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面例子展示的配置，使PagedResourcesAssembler作为控制类参数。调用toResources(…)有如下影响：</p>
<ul>
<li>Page的内容变为PagedResources实例的内容</li>
<li>PageResources对象获得一个PageMetaData实例，该实例被来自Page和底层PageRequest信息填充。</li>
<li>根据page的状态，PageResources可能会获得附带的向前和向后的链接。链接指向方法集合的URI。添加到方法的参数和PageableHandlerMethodArgumentResolver的设置相匹配，以确保稍后可以解析链接。</li>
</ul>
<p>假定在数据库有30个Person实例，你现在可以触发一个请求（GET请求 <a href="http://localhost:8080/persons），获得类似如下输出：" target="_blank" rel="noopener">http://localhost:8080/persons），获得类似如下输出：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;links&quot; : [ &#123; &quot;rel&quot; : &quot;next&quot;,</span><br><span class="line">                &quot;href&quot; : &quot;http://localhost:8080/persons?page=1&amp;size=20 &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;content&quot; : [</span><br><span class="line">     … // 20 Person instances rendered here</span><br><span class="line">  ],</span><br><span class="line">  &quot;pageMetadata&quot; : &#123;</span><br><span class="line">    &quot;size&quot; : 20,</span><br><span class="line">    &quot;totalElements&quot; : 30,</span><br><span class="line">    &quot;totalPages&quot; : 2,</span><br><span class="line">    &quot;number&quot; : 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以看到assembler生成了正确的URI，选择默认配置解析参数到请求中的Pageable。这意味着，如果你改变配置，链接会自动修改。默认情况下，assembler指向它调用的控制层方法，但是可以被自定义，通过提供自定义链接当作构建分页链接基础使用，该自定义assembler重写PagedResourcesAssembler.toResource(…)方法。</p>
<p><strong>Web数据绑定支持</strong></p>
<p>Spring Data映射（描述在Projections）可以用来绑定传入请求的有效负载，通过使用JSONPath表达式（需要Jayway Json）或XPath表达式（需要XmlBeam）,如下实例所示：</p>
<p>例子46：使用JSONPath和XPath表达式绑定HTTP有效负载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ProjectedPayload</span><br><span class="line">public interface UserPayload &#123;</span><br><span class="line"></span><br><span class="line">  @XBRead(&quot;//firstname&quot;)</span><br><span class="line">  @JsonPath(&quot;$..firstname&quot;)</span><br><span class="line">  String getFirstname();</span><br><span class="line"></span><br><span class="line">  @XBRead(&quot;/lastname&quot;)</span><br><span class="line">  @JsonPath(&#123; &quot;$.lastname&quot;, &quot;$.user.lastname&quot; &#125;)</span><br><span class="line">  String getLastname();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面实例展示的类型可以用作Spring MVC处理方法的参数，或通过使用ParameterizedTypeReference在某个RestTemplate的方法上。前面的方法声明厂商在给定文档的任何地方尝试查找firstname。lastname的XML查找在传入文东的顶层执行。JSON变量首先尝试顶层变量，如果没有返回一个值，也会尝试嵌套在user子文档中。这样，源文档结构的变化可以被减少，而不需要客户端调用暴露的方法（通常是基于类的有效负载绑定的缺点）。</p>
<p>嵌套映射被支持，如在Projections描述。如果接口返回复杂的非接口类型，则使用Jackson ObjectMapper映射最终值。</p>
<p>对于Spring MVC，必要的转化器已经自动注册了，只要使用了@EnableSpringDataWebSupport，和需要的依赖已经在类路径上。对于使用RestTemplate，手动注册ProjectingJackson2HttpMessageConverter (JSON) 或者XmlBeamHttpMessageConverter。</p>
<p>获取更多信息，查看web映射例子，在Spring Data例子repository典范中。</p>
<p><strong>Querydsl Web支持</strong></p>
<p>对于那些有QueryDSL整合的存储库，可以从Request字符串包括的属性派生查询。</p>
<p>考虑如下查询字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?firstname=Dave&amp;lastname=Matthews</span><br></pre></td></tr></table></figure></p>
<p>给定前面例子的User对象，通过使用QuerydslPredicateArgumentResolver将查询字符串解析为如下值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</span><br></pre></td></tr></table></figure></p>
<p>该特征是自动开启的，随着@EnableSpringDataWebSupport，当QueryDsl在类路径下找到。</p>
<p>添加到@QuerydslPredicate方法签名提供一个准备使用的Predicate，通过使用QuerydslPredicateExecutor可以运行。</p>
<p>！通常从方法返回类型解析类型参数。由于该信息不一定匹配域类型，使用QuerydslPredicate的root属性是一个好主意。</p>
<p>如下示例展示如何在方法签名使用@QuerydslPredicate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">class UserController &#123;</span><br><span class="line"></span><br><span class="line">  @Autowired UserRepository repository;</span><br><span class="line"></span><br><span class="line">  @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)</span><br><span class="line">  //解析查询字符串参数匹配User的Predicate</span><br><span class="line">  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,    </span><br><span class="line">          Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) &#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;users&quot;, repository.findAll(predicate, pageable));</span><br><span class="line"></span><br><span class="line">    return &quot;index&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认绑定如下：</p>
<ul>
<li>Object在简单属性为.eq</li>
<li>Object在结合类似属性为contains</li>
<li>Collection在简单属性为in</li>
</ul>
<p>这些绑定可以被定制化，通过@QuerydslPredicate的binding属性，或者通过使用Java8默认方法和添加QuerydslBinderCustomizer 方法到repository接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//QuerydslPredicateExecutor为Predicate提供访问特殊查找方法</span><br><span class="line">//定义在repository接口的QuerydslBinderCustomizer ，自动获取和快捷方式@QuerydslPredicate(bindings=…​)</span><br><span class="line">interface UserRepository extends CrudRepository&lt;User, String&gt;,</span><br><span class="line">                                 QuerydslPredicateExecutor&lt;User&gt;,                </span><br><span class="line">                                 QuerydslBinderCustomizer&lt;QUser&gt; &#123;               </span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  default void customize(QuerydslBindings bindings, QUser user) &#123;</span><br><span class="line">    //定义username属性绑定到简单contains绑定</span><br><span class="line">    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    </span><br><span class="line">    //定义字符串属性的默认绑定到不区分大小写的contains的匹配</span><br><span class="line">    bindings.bind(String.class)</span><br><span class="line">      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); </span><br><span class="line">    // 从Predicate解析中排查password属性</span><br><span class="line">    bindings.excluding(user.password);                                           </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-8-3-Repository填充器"><a href="#4-8-3-Repository填充器" class="headerlink" title="4.8.3. Repository填充器"></a>4.8.3. Repository填充器</h3><p>如果你使用Spring JDBC模块，你可能属性使用SQL脚本填充DataSource的支持。在repository层有类似的抽象可以使用，尽管它不适用SQL作为数据定义语言，因为它必须存储独立。因此，填充器支持XML（通过Spring的OXM抽象）和JSON(通过Jackson)来定义填充到repository的数据。</p>
<p>假如你有一个文件data.json,如下内容：</p>
<p>例子47. 数据定义JSON格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; &quot;_class&quot; : &quot;com.acme.Person&quot;,</span><br><span class="line"> &quot;firstname&quot; : &quot;Dave&quot;,</span><br><span class="line">  &quot;lastname&quot; : &quot;Matthews&quot; &#125;,</span><br><span class="line">  &#123; &quot;_class&quot; : &quot;com.acme.Person&quot;,</span><br><span class="line"> &quot;firstname&quot; : &quot;Carter&quot;,</span><br><span class="line">  &quot;lastname&quot; : &quot;Beauford&quot; &#125; ]</span><br></pre></td></tr></table></figure></p>
<p>你可以使用Spring Data Commons提供的repository命名空间的填充元素来填充你的repositories。填充预定数据到你的PersonRepository,声明一个类似如下的填充器：<br>例子48. 声明一个Jackson repository填充器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:repository=&quot;http://www.springframework.org/schema/data/repository&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://www.springframework.org/schema/data/repository</span><br><span class="line">    http://www.springframework.org/schema/data/repository/spring-repository.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;repository:jackson2-populator locations=&quot;classpath:data.json&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>前面的声明导致data.json文件可以被读取和通过Jackson ObjectMapper反序列化。</p>
<p>JSON对象解组的类型通过检查JSON文档的_class属性来确定。基础结构甚至选择了相应了repository处理反序列化的对象。</p>
<p>代替使用XML定义repository应该被填充的数据，你可以使用unmarshaller-populator 元素。你配置它，以使用XML编制选项的一个，在Spring OXM。查看Spring参考文档更多详情。如下示例展示如何使用JAXB解组一个repository填充器：</p>
<p>例子49：声明一个解组repository填充器（使用JAXB）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:repository=&quot;http://www.springframework.org/schema/data/repository&quot;</span><br><span class="line">  xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://www.springframework.org/schema/data/repository</span><br><span class="line">    http://www.springframework.org/schema/data/repository/spring-repository.xsd</span><br><span class="line">    http://www.springframework.org/schema/oxm</span><br><span class="line">    http://www.springframework.org/schema/oxm/spring-oxm.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;repository:unmarshaller-populator locations=&quot;classpath:data.json&quot;</span><br><span class="line">    unmarshaller-ref=&quot;unmarshaller&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;oxm:jaxb2-marshaller contextPath=&quot;com.acme&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/" itemprop="url">postman中form-data和x-www-form-urlencoded的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T00:45:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/常见问题/" itemprop="url" rel="index">
                    <span itemprop="name">常见问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对应的请求头中的content-type"><a href="#对应的请求头中的content-type" class="headerlink" title="对应的请求头中的content-type"></a>对应的请求头中的content-type</h3><ul>
<li>form-data 对应 multipart/form-data</li>
<li>x-www-form-urlencoded 对应 application/x-www-form-urlencoded</li>
</ul>
<h3 id="postman上的直观区别"><a href="#postman上的直观区别" class="headerlink" title="postman上的直观区别"></a>postman上的直观区别</h3><p><img src="/images/form-data.png" alt="form-data"></p>
<img src="/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/x-www-form-urlencoded.png" title="x-www-form-urlencoded格式图片">
<p>可以看到，form-data格式可以上传File,对的，这就是最大的区别。</p>
<h3 id="请求体内容格式区别"><a href="#请求体内容格式区别" class="headerlink" title="请求体内容格式区别"></a>请求体内容格式区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/test&quot;)</span><br><span class="line">public void test(HttpServletRequest request) &#123;</span><br><span class="line">    System.out.println(&quot;请求头：&quot;);</span><br><span class="line">    String header = request.getHeader(&quot;content-type&quot;);</span><br><span class="line">    System.out.println(&quot;content-type:&quot; + header);</span><br><span class="line">    System.out.println(&quot;请求体：&quot;);</span><br><span class="line">    try (BufferedReader reader = request.getReader())&#123;</span><br><span class="line">        String s;</span><br><span class="line">        while ((s = reader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125; catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上面一段代码打印出请求类型和请求体，结果见下图：</p>
<img src="/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/form-data-request.png">
<p>form-data请求的请求体格式复杂（下面一个是文件流，没有截全）</p>
<img src="/2018/07/02/question/postman中form-data和x-www-form-urlencoded的区别/x-www-form-urlencoded-request.png">
<p>x-www-form-urlencoded请求体中的格式就和get请求一样，参数键值对拼接放在请求体中</p>
<h3 id="Spring-MVC中支持multipart-form-data格式"><a href="#Spring-MVC中支持multipart-form-data格式" class="headerlink" title="Spring MVC中支持multipart/form-data格式"></a>Spring MVC中支持multipart/form-data格式</h3><p>需要配置MultipartResolver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MultipartResolver multipartResolver()&#123;</span><br><span class="line">    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();</span><br><span class="line">    multipartResolver.setMaxUploadSize(1000000);</span><br><span class="line">    return  multipartResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用实体接收参数后，再从request中读取不到请求体"><a href="#用实体接收参数后，再从request中读取不到请求体" class="headerlink" title="用实体接收参数后，再从request中读取不到请求体"></a>用实体接收参数后，再从request中读取不到请求体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/test1&quot;)</span><br><span class="line">public void test1(DemoObj obj, HttpServletRequest request) &#123;</span><br><span class="line">    System.out.println(obj.toString());</span><br><span class="line">    System.out.println(&quot;请求头：&quot;);</span><br><span class="line">    String header = request.getHeader(&quot;content-type&quot;);</span><br><span class="line">    System.out.println(&quot;content-type:&quot; + header);</span><br><span class="line">    System.out.println(&quot;请求体：&quot;);</span><br><span class="line">    try(InputStream is = request.getInputStream()) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        byte[] b = new byte[4096];</span><br><span class="line">        for (int n; (n = is.read(b)) != -1;) &#123;</span><br><span class="line">            sb.append(new String(b, 0, n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DemoObj&#123;id=1, name=&apos;hello&apos;&#125;</span><br><span class="line">请求头：</span><br><span class="line">content-type:multipart/form-data; boundary=----WebKitFormBoundaryPh2Rl1iCPOcVhss9</span><br><span class="line">请求体：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DemoObj&#123;id=1, name=&apos;hello&apos;&#125;</span><br><span class="line">请求头：</span><br><span class="line">content-type:application/x-www-form-urlencoded</span><br><span class="line">请求体：</span><br></pre></td></tr></table></figure>
<p>再从request中读取请求体失败，是因为在这之前已经读过一次流，具体Controller如何接收参数，后续有时间再去研究源码吧。</p>
<p>也可参考下<a href="https://www.cnblogs.com/sunny3096/p/7215906.html" target="_blank" rel="noopener">这篇文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/test/HelloWorld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/29/test/HelloWorld/" itemprop="url">HelloWorld</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T21:27:33+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/29/test/HelloWorld/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/29/test/HelloWorld/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center>《一切》</center><br><center>一切都是命运</center><br><center>一切都是烟云</center><br><center>一切都是没有结局的开始</center><br><center>一切都是稍纵即逝的追寻</center><br><center>一切欢乐都没有微笑</center><br><center>一切苦难都没有泪痕</center><br><center>一切语言都是重复</center><br><center>一切交往都是初逢</center><br><center>一切爱情都在心里</center><br><center>一切往事都在梦中</center><br><center>一切希望都带着注释</center><br><center>一切信仰都带着呻吟</center><br><center>一切爆发都有片刻的宁静</center><br><center>一切死亡都有冗长的回声</center>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/28/translate/第一部分 Spring Boot文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peter peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="peter阡陌">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/translate/第一部分 Spring Boot文档/" itemprop="url">第一部分 Spring Boot文档</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T22:09:05+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot-2-0-3-RELEASE-参考指南翻译/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot 2.0.3.RELEASE 参考指南翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/28/translate/第一部分 Spring Boot文档/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/28/translate/第一部分 Spring Boot文档/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PartⅠSpring-Boot文档"><a href="#PartⅠSpring-Boot文档" class="headerlink" title="PartⅠSpring Boot文档"></a>PartⅠSpring Boot文档</h1><p>本节简要概述了Spring Boot参考文档，当做文档其余部门的映射。</p>
<h2 id="1-关于文档"><a href="#1-关于文档" class="headerlink" title="1. 关于文档"></a>1. 关于文档</h2><p>Spring Boot参考文档可获取的格式有：</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html" target="_blank" rel="noopener">HTML</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/pdf/spring-boot-reference.pdf" target="_blank" rel="noopener">PDF</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/epub/spring-boot-reference.epub" target="_blank" rel="noopener">EPUB</a>(注：适应设备阅读的电子格式)</li>
</ul>
<p>最新副本可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference</a>获得</p>
<p>文档副本可以被你自己使用或分发给他人，前提是不能收取费用及每个副本都要包含该版权申明，不管是印刷版还是电子版</p>
<h2 id="2-获取帮助"><a href="#2-获取帮助" class="headerlink" title="2. 获取帮助"></a>2. 获取帮助</h2><p>如果你遇到Spring Boot的问题，我们希望能提供帮助</p>
<ul>
<li>试读How-to documents，他们提供了最常见问题的解决办法</li>
<li>学习Spring基础，Spring Boot建立在多个其他Spring项目上。查阅官网获取大量参考文档，如果你刚开始使用Spring，尝试其中一个指南</li>
<li>问问题，我们会监视stackoverflow.com上带spring-boot标签的问题</li>
<li>在<a href="https://github.com/spring-projects/spring-boot/issues" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues</a>报告Spring Boot的bugs</li>
</ul>
<p><strong>叶</strong>| Spring Boot是开源的，包括文档。如果你发现了文档的问题并想改善它，请参与。</p>
<h2 id="3-第一步"><a href="#3-第一步" class="headerlink" title="3. 第一步"></a>3. 第一步</h2><p>如果你刚开始使用Spring Boot或Spring,请从下面主题开始：</p>
<ul>
<li>从头开始：概述|要求|安装</li>
<li>教程：Part 1|Part 2</li>
<li>运行例子：Part 1|Part 2</li>
</ul>
<h2 id="4-使用Spring-Boot"><a href="#4-使用Spring-Boot" class="headerlink" title="4. 使用Spring Boot"></a>4. 使用Spring Boot</h2><p>准备好真正开始使用Spring Boot？已为你提供：</p>
<ul>
<li>构建系统：Maven|Gradle|Ant|Starters</li>
<li>最佳实践：代码结构|@Configuration|@EnableAutoConfiguration|Beans和依赖注入</li>
<li>运行代码：IDE|Packaged|Maven|Gradle</li>
<li>打包运用：生成jars包</li>
<li>Spring Boot CLI：使用CLI</li>
</ul>
<h2 id="5-学习Spring-Boot特征"><a href="#5-学习Spring-Boot特征" class="headerlink" title="5. 学习Spring Boot特征"></a>5. 学习Spring Boot特征</h2><p>需要了解Spring Boot核心特征的细节？为你提供下面内容：</p>
<ul>
<li>核心特征：SpringApplication|External Configuration|Profiles|Logging</li>
<li>Web运用：MVC|嵌入式容器</li>
<li>使用数据：SQL|NO-SQL</li>
<li>消息：概述|JMS</li>
<li>测试：概述|Boot Applications|Utils</li>
<li>扩展：Auto-Cofiguration|@Conditions</li>
</ul>
<h2 id="6-生产运用"><a href="#6-生产运用" class="headerlink" title="6. 生产运用"></a>6. 生产运用</h2><p>当你准备把Spring Boot运用发布到生产环境，我们有一些你会喜欢的技巧：</p>
<ul>
<li>管理节点：概述|定制化</li>
<li>连接选择：HTTP|JMX</li>
<li>监控：Metrics|Auditing|Tracing|Process</li>
</ul>
<h2 id="7-高级主题"><a href="#7-高级主题" class="headerlink" title="7. 高级主题"></a>7. 高级主题</h2><p>最后，我们有一些为更高级用户准备的主题</p>
<ul>
<li>Spring Boot运用部署：Cloud Deployment|OS Service</li>
<li>构建工具插件：Maven|Gradle</li>
<li>附录：Application Properties|Auto-Configuration classes|可执行的jars包</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="peter peng" />
            
              <p class="site-author-name" itemprop="name">peter peng</p>
              <p class="site-description motion-element" itemprop="description">最是那一低头的温柔，像一朵水莲花，不胜凉风的娇羞</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">peter peng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://https-zhifengpeng-github-io.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
